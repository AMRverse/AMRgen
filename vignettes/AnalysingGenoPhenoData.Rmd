---
title: "AnalysingGenoPhenoData"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{AnalysingGenoPhenoData}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 10,
  out.width = "100%"
)
```

```{r setup}
library(AMRgen)
```

# Introduction

AMRgen is a comprehensive R package designed to integrate antimicrobial resistance genotype and phenotype data. It provides tools to:

* Import AMR genotype data (e.g. from AMRFinderPlus, hAMRonization)

* Import AST phenotype data (e.g. from NCBI)

* Conduct genotype-phenotype analyses to explore the impact of genotypic markers on phenotype, including via logistic regression, solo marker analysis, and upset plots

* Fetch MIC or disk zone reference distributions from EUCAST

This vignette walks through a basic workflow using example datasets included in the AMRgen package, and explains how to wrangle your own data files into the right formats to use the same workflow.


## 1. Genotype table
The `import_amrfp()` function lets you load genotype data from AMRFinderPlus outputs, and process it to generate an object with the key columns needed to work with AMRgen packages.

``` {r import_amrfp}
# Example AMRfinderplus genotyping output
ecoli_geno_raw

# Load AMRfinderplus output 
#    (replace 'ecoli_geno_raw' with the filepath for any AMRfinderplus output)
ecoli_geno <- import_amrfp(ecoli_geno_raw, "Name")

# Check the format of the processed genotype table
head(ecoli_geno)
```

The genotype table has one row for each genetic marker detected in an input genome, i.e. one per strain/marker combination.

If your genotype data is not in AMRfinderplus format, you can wrangle other input data files into the necessary format.

The essential columns for a genotype table to work with AMRgen functions are:

* `Name`: character string giving the sample name, used to link to sample names in the phenotype file (this column can have a different name, in which case you'll need to make sure it is the first column in the dataframe OR pass its name to the functions using `geno_sample_col`)

* `marker`: character string giving the name of the genetic marker detected

* `drug_class`: character string giving the antibiotic class associated with this marker

NOTE: You should consider whether you have genomes with no AMR markers detected by genotyping, and how to make sure these are include in your analyses. E.g. AMRfinderplus will output one row per genome/marker combination, but if you have a genome with no markers detected, there will be no row at all for that genome in the concatenated output file. If your species has core genes included in AMRfinderplus this probably won't be a problem as you would expect some calls for every genome (e.g. AMRfinderplus will report blaSHV, oqxA, oqxB, fosA in all Klebsiella pneumoniae genomes, so all input genomes will appear in the concatenated output file). An easy solution is to run a check to make sure that all genome names in your input dataset are represented in the genotype table, and if any are missing add empty rows for these using e.g. `tibble(Name=missing_samples) %>% bind_rows(genotype_table)`.

## 2. Phenotype table
The `import_ncbi_ast()` function imports AST data from NCBI format files.

``` {r import_ncbi_ast}
# Example E. coli AST data from NCBI 
# This one has already been imported and phenotypes interpreted from assay data
# You can make your own from NCBI format data using: 
#    import_ncbi_ast("filepath/AST.tsv", interpret=T)
ecoli_ast

head(ecoli_ast)
```

The phenotype table has one row for each assay measurement, i.e. one per strain/drug combination.
If your assay data is not in NCBI AST format, you can wrangle other input data files into the necessary format.

The essential columns for a phenotype table to work with AMRgen functions are:

* `id`: character string giving the sample name, used to link to sample names in the genotype file (this column can have a different name, in which case you'll need to make sure it is the first column in the dataframe OR pass its name to the functions using `pheno_sample_col`)

* `spp_pheno`: species in the form of an AMR package `mo` class (can be created from a column with species name as string, using `AMR::as.mo(species_string)`)

* `drug_agent`: antibiotic name in the form of an AMR package `ab` class (can be created from a column with antibiotic name as string, using `AMR::as.ab(antibiotic_string)`)

* `pheno`: S/I/R phenotype calls in the form of an AMR package `sir` class (can be created from a column with phenotype values as string, using `AMR::as(sir_string)`, or generated by interpreting MIC or disk assay data using `AMR::as.sir`)

If you want to do analyses with raw assay data (e.g. upset plots) you will need that data in one or both of: 

* `mic`: MIC in the form of an AMR package `mic` class (can be created from a column with assay values as string, using `AMR::as.mic(mic_string)`)

* `disk`: disk diffusion zone diameter in the form of an AMR package `disk` class (can be created from a column with assay values as string, using `AMR::as.disk(disk_string)`)

## 3. Combine genotype and phenotype data for a given drug

The genotype and phenotype tables can include data related to many different drugs, but we need to analyse things one drug at a time. The function `get_binary_matrix()` can be used to extract phenotype data for a specified drug, and genotype data for markers associated with a specified drug class. It returns a single dataframe with one row per strain, for the subset of strains that appear in both the genotype and phenotype input tables. Each row indicates, for one strain, both the phenotypes (with SIR column, any assay columns if desired, and boolean 1/0 coding of R and NWT status) and the genotypes (one column per marker, with boolean 1/0 coding of marker presence/absence).

``` {r get_binary_matrix}
# Get matrix combining phenotype data for ciprofloxacin, binary calls for R/NWT phenotype,
#    and genotype presence/absence data for all markers associated with the relevant drug 
#    class (which are labelled "Quinolones" in AMRfinderplus).
cip_bin <- get_binary_matrix(ecoli_geno, ecoli_ast, antibiotic="Ciprofloxacin", drug_class_list=c("Quinolones"), sir_col="pheno", keep_assay_values=T, keep_assay_values_from = "mic")

# check format
head(cip_bin)

# list colnames, to see full list of quinolone markers included
colnames(cip_bin)
```

## 4. Model a binary drug phenotype using genetic marker presence/absence data

Logistic regression models can be informative to get an overview of the association between a drug resistance phenotype, and each marker thought to be associated with the relevant drug class.

The `amr_logistic()` function uses the `get_binary_matrix` function to generate binary-coded genotype and phenotype data for a specified drug and class; and fits two logistic regression models of the form `R ~ marker1 + marker2 + marker3 + ...` and `NWT ~ marker1 + marker2 + marker3 + ...`. 

Note that the 'NWT' variable in the latter model can be taken either from a precomputed ECOFF-based call of WT=wildtype/NWT=nonwildtype (encoded in the input column `ecoff_col`), or computed from the S/I/R phenotype as NWT=R/I and WT=S.

The `amr_logistic()` function can fit the model using either the standard logistic regression approach implemented in the `glm()` function, or Firth's bias-reduced penalized-likelihood logistic regression implemented in the `logistf` package. The default is to use Firth's regression, as standard logistic regression can fail if there are too observations in some subgroups, which happens quite often with this kind of data. To use `glm()` instead, set `glm=TRUE`.

The function also filters out markers with too few observations in the combined genotype/phenotype dataset. The default minimum is 10 but this can be changed using the `maf` parameter (maf stands for 'minor allele frequency'). If you are having trouble fitting models, it may be because too many markers and combinations have very few observations, and you might try increasing the `maf` value to ensure that rare markers are excluded prior to model fitting.

Using this modelling approach, a negative assocation with a single marker and phenotype call of R and NWT is a strong indication that marker does not contribute to resistance. Note however that a positive association between a marker and R or NWT does not necessarily imply the marker is independently contributing to the resistance phenotype, as there may be non-independence between markersthat is not adequately adjusted for by the model.

The function returns 4 objects:

* `modelR, modelNWT`: data frames summarising each model, with beta coefficient, lower and upper values of 95% confidence intervals, and p-value for each marker (generated from the raw model output using `logistf_details()` or `glm_details()` as relevant)

* `plot`: a ggplot2 object generated from the `modelR` and `modelNWT` objects using the `compare_estimates()` function

* `bin_mat`: the binary matrix used as input to the regression models

``` {r manual_logistic, fig.height=8}
# Manually run Firth's logistic regression model using the binary matrix produced above
dataR <- cip_bin[, setdiff(names(cip_bin), c("id", "pheno", "mic", "NWT"))]
modelR <- logistf::logistf(R ~ ., data=dataR)

summary(modelR)

# Extract model summary details using `logistf_details()`
modelR_summary <- logistf_details(modelR)

modelR_summary

# Plot the point estimates and 95% confidence intervals of the model
plot_estimates(modelR_summary)

```

``` {r amr_logistic, fig.height=8}
# Alternatively, use the amr_logistic() function to model R and NWT and plot the results together
models <- amr_logistic(geno_table = import_amrfp(ecoli_geno_raw, "Name"), pheno_table = ecoli_ast, 
                       antibiotic = "Ciprofloxacin", drug_class_list = c("Quinolones"), maf=10)

# Output tables
models$modelR

models$modelNWT

# Note the matrix output is the same as cip_bin, but without the MIC data as this is not required
#    for logistic regression.
models$bin_mat
```

## 5. Assess solo positive predictive value of genetic markers

The strongest evidence of the effect of an individual genetic marker on a drug phenotype is its positive predictive value (PPV) for resistance amongst strains that carry this marker 'solo' with no other markers known to be associated with resistance to the drug class. This is referred to as 'solo PPV'. 

The function `solo_ppv_analysis()` takes as input our genotype and phenotype tables, and calculates solo PPV for resistance to a specific drug (included in our phenotype table) formarkers associated with the specified drug class (included in our genotype table). It uses the `get_binary_matrix()` function to first calculate the binary matrix, then filters out all samples that have more than one marker.

It then calculates for each remaining marker, amongst the genomes in which that marker is found solo, the number of genomes, the number and proportion that are R or NWT, and the 95% confidence intervals for these proportions. The values are returned as a table, and also plotted so we can easily visualise the distribution of S/I/R calls and the solo PPV for R and NWT, for each solo marker.

The function returns 4 objects:

* `solo_stats`: data frame containing the numbers, proportions and confidence intervals for PPV of R and NWT categories

* `amr_binary`: the (wide format) binary matrix for all strains with geno/pheno data for the specified drug/class

* `solo_binary`: the (long format) binary matrix for only those strains in which a solo marker was found, i.e. the data used to calculate PPV

* `combined_plot`: a plot showing the distribution of S/I/R calls and the solo PPV for R and NWT, for each solo marker

``` {r solo_ppv_analysis, fig.height=8}
# Run a solo PPV analysis
soloPPV_cipro <- solo_ppv_analysis(ecoli_geno, ecoli_ast, antibiotic="Ciprofloxacin", drug_class_list=c("Quinolones"), sir_col="pheno")

# Output table
soloPPV_cipro$solo_stats

# Interim matrices with data used to compute stats and plots
soloPPV_cipro$solo_binary

soloPPV_cipro$amr_binary
```

## 6. Compare markers with assay data

So far we have considered only the impact of individual markers, and their association with categorical S/I/R or WT/NWT calls.

The function `amr_upset()` takes as binary matrix table `cip_bin` summarising ciprofloxacin resistance vs quinolone markers, generated using `get_binary_matrix()`, and explores the distribution of MIC or disk diffusion assay values for all observed combinations of markers (solo or multiple markers). It visualises the data in the form of an upset plot, showing the distribution of assay values and S/I/R calls for each observed marker combination, and returns a summary of these distributions (including sample size, median and interquartile range, number and proportion classified as R).

The function returns 2 objects:

* `summary`: data frame containing summarising the data associated with each combination of markers

* `plot`: an upset plot showing the distribution of assay values, and breakdown of S/I/R calls, for each observed marker combination

``` {r amr_upset, fig.height=8}
# Compare ciprofloxacin MIC data with quinolone marker combinations,
#    using the binary matrix we constructed earlier via get_binary_matrix()
cipro_mic_upset <- amr_upset(cip_bin, min_set_size=2, assay="mic", order="value")

# Output table
cipro_mic_upset$summary
```

## 7. Download reference MIC distributions and compare to your data

``` {r get_eucast_distribution}
# get MIC distribution for ciprofloxacin, for all organisms
get_eucast_mic_distribution("cipro")

# specify microorganism to only get results for that pathogen
ecoli_cip_mic_data <- get_eucast_mic_distribution("cipro", "E. coli")

# get disk diffusion data instead
ecoli_cip_disk_data <- get_eucast_disk_distribution("cipro", "E. coli")

# plot the MIC data 
mics <- rep(ecoli_cip_mic_data$mic, ecoli_cip_mic_data$count)
ggplot2::autoplot(mics, ab = "cipro", mo = "E. coli", title = "E. coli cipro reference distribution")

```

``` {r compare_mic_with_eucast}
# Compare reference distribution to random test data
my_mic_values <- AMR::random_mic(500)
comparison <- compare_mic_with_eucast(my_mic_values, ab = "cipro", mo = "E. coli")
comparison
ggplot2::autoplot(comparison)


# Compare reference distribution to example E. coli data
ecoli_cip <- ecoli_ast$mic[ecoli_ast$drug_agent=="CIP"]
comparison <- compare_mic_with_eucast(ecoli_cip, ab = "cipro", mo = "E. coli")
comparison
ggplot2::autoplot(comparison) + ggtitle("E. coli - Ciprofloxacin")
```